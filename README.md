# Microservice-Testing
This project is a POC of Spring Cloud Contract which enables Consumer Driven Contract (CDC) development of JVM-based applications. It moves TDD to the level of software architecture.

## Consumer Driven Contract?
There're 2 ways to test microservices 
* Deploy all microservices and perform end-to-end tests.
* Mock other microservices in unit/integration tests.

The above method is not really work well for us during testing microservices, here is how I think:

### Deploy all microservices and perform end-to-end tests
* To test one microservice, we have to deploy other microservices, a couple of databases, etc.
* It takes so long time to run, and some functinality might be limited for us to test in real runtime system. ex. account doesn't not have that specific feature, will spend more time to create that account.
* Hard to debug the code

Then we come up with the idea to mock up all the other service so it will be run fast and you will be able to stub the data you want :)

### However Mock other microservices in unit/integration tests
* The stub create for microservices doesn't synchronize with the reality (production code). If the service code change then you will need to your stub in the mock service which will cause high chance of inconsistent.
* What you test with the stub might not be what in the production.

### So, Spring Clould Contract Verifier with Stub Runner will solve the these issues
The idea behind CDC (Consumer Driven Contracts) is to share the contract between the sides of the communication.
* To provide a way to publish changes in contracts that are immediately visible on both sides of the communication. ex. create stub contract in server side, which use to test both server and client code to secure the synchronization. 
* To ensure that WireMock/Messaging stubs (used when developing the client) do exactly what the actual server-side implementation does.
* To promote ATDD method and Microservices architectural style.
* To generate boilerplate test code to be used on the server side.

## How it works?
### Defining the contract
you can define the contract in `src/test/resources/contracts`  
`food/shoudGetAllFoods.groovy`
```groovy
package food

import org.springframework.cloud.contract.spec.Contract

Contract.make {
    request {
        method 'GET'
        url '/foods'
    }
    response {
        status 200
        body([[id: 1L, name: "Rice", description: "White Rice"], [id: 2L, name: "Fried Rice", description: "Premium Rice"]])
        headers {
            header('Content-Type', 'application/json;charset=UTF-8')
        }
    }
}
```
Base on the contract, Spring Cloud Contract Gradle and Maven plugins help you with that by generating a jar with stubs and contract definitions with a stubs classifier(`food-server-0.0.1-SNAPSHOT-stubs.jar`). Just upload it to some central repository where others can reuse it for their integration tests.
### Verified with Server Side Concrete Implementation
Since you are developing your stub, you need to be sure that it actually resembles your concrete implementation. You cannot have a situation where your stub acts in one way and your application behaves in a different way, especially in production.

To ensure that your application behaves the way you define in your stub, tests are auto-generated from the stub you provide.

The autogenerated test looks like this:
```java
public class FoodTest extends FoodBase {

	@Test
	public void validate_shoudGetAllFoods() throws Exception {
		// given:
			MockMvcRequestSpecification request = given();

		// when:
			ResponseOptions response = given().spec(request)
					.get("/foods");

		// then:
			assertThat(response.statusCode()).isEqualTo(200);
			assertThat(response.header("Content-Type")).isEqualTo("application/json;charset=UTF-8");
		// and:
			DocumentContext parsedJson = JsonPath.parse(response.getBody().asString());
			assertThatJson(parsedJson).array().contains("['id']").isEqualTo(2L);
			assertThatJson(parsedJson).array().contains("['description']").isEqualTo("White Rice");
			assertThatJson(parsedJson).array().contains("['name']").isEqualTo("Fried Rice");
			assertThatJson(parsedJson).array().contains("['description']").isEqualTo("Premium Rice");
			assertThatJson(parsedJson).array().contains("['id']").isEqualTo(1L);
			assertThatJson(parsedJson).array().contains("['name']").isEqualTo("Rice");
	}
}
```

### Client Side test stub using Spring Cloud Contract Stub Runner
Spring Cloud Contract generates stubs, which you can use during client-side testing. You get a running WireMock instance/Messaging route that simulates the service. In here the StubRunner will base on the groupd id to retrieve the stub artifact (`food-server-0.0.1-SNAPSHOT-stubs.jar`) from your local maven repo since we define `stubsMode = StubRunnerProperties.StubsMode.LOCAL`
```java
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureStubRunner(ids = {"com.egen:food-server:+:stubs:8080"}, stubsMode = StubRunnerProperties.StubsMode.LOCAL)
public class FoodClientTest {

    @Autowired
    private FoodClient foodClient;
    
    @Before
    public void setUp() throws Exception {
    }

    @Test
    public void whenGetFoods_thenReturnFoods(){
        List<Food> foodList = foodClient.getFoods();
        assertThat(foodList).isNotEmpty();
        assertThat(foodList.stream().filter(food -> food.getName().equals("Rice")).count()).isEqualTo(1);
    }
}
```
### Summary Spring Cloud Contract Flow
```bash
> Task :food-server:copyContracts - Copies contracts to the output folder
> Task :food-server:generateClientStubs - Generate client stubs from the contracts (stubs/mappings/)
> Task :food-server:verifierStubsJar - Creates the stubs JAR task
> Task :food-server:generateContractTests - Generate server tests from the contracts
> Task :food-server:test - Run all test case to verified server code and stubs
```
#### publish stub artifact to local maven repo
```
./gradlew publishStubsPublicationToMavenLocal
```
### Technology Stacks
* WireMock : Spring Cloud Contract Stub Runner use **WireMock** to run the Mock Server which inject the stub(`stubs/mappings/*.json`) from the stub artifact into it.
* RestAssured: Spring Cloud Contract Verifier use **RestAssured** as MockMvc test engine for auto-generated boilerplate test code.

## Reference
https://cloud.spring.io/spring-cloud-contract/  
https://cloud.spring.io/spring-cloud-static/spring-cloud-contract/1.2.1.RELEASE/single/spring-cloud-contract.html#_spring_cloud_contract  
https://cloud.spring.io/spring-cloud-contract/multi/multi__spring_cloud_contract_verifier_setup.html
